# 递归

## [46. 全排列](https://leetcode-cn.com/problems/permutations/)

### 方法一： 递归

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
// 入参是一个数组
const permute = function(nums) {
  // 缓存数组的长度
  const len = nums.length
  // curr 变量用来记录当前的排列内容
  const curr = []
  // res 用来记录所有的排列顺序
  const res = []
  // visited 用来避免重复使用同一个数字
  const visited = {}
  // 定义 dfs 函数，入参是坑位的索引（从 0 计数）
  function dfs(nth) {
      // 若遍历到了不存在的坑位（第 len+1 个），则触碰递归边界返回
      if(nth === len) {
          // 此时前 len 个坑位已经填满，将对应的排列记录下来
          res.push(curr.slice())
          return 
      }
      // 检查手里剩下的数字有哪些
      for(let i=0;i<len;i++) {
          // 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”
          if(!visited[nums[i]]) {
              // 给 nums[i] 打个“已用过”的标
              visited[nums[i]] = 1
              // 将nums[i]推入当前排列
              curr.push(nums[i])
              // 基于这个排列继续往下一个坑走去
              dfs(nth+1) 
              // nums[i]让出当前坑位
              curr.pop()
              // 下掉“已用过”标识
              visited[nums[i]] = 0
          }
      }
  }
  // 从索引为 0 的坑位（也就是第一个坑位）开始 dfs
  dfs(0)
  return res
};
```

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
const permute = (nums) => {
  const res = []
  const used = {}

  function dfs(path) {
    if (path.length == nums.length) {
      // 个数选够了
      res.push(path.slice()) // 拷贝一份path，加入解集res
      return // 结束当前递归分支
    }
    for (const num of nums) {
      // for枚举出每个可选的选项
      // if (path.includes(num)) continue; // 别这么写！查找的时间是O(n)，增加时间复杂度
      if (used[num]) continue // 使用过的，跳过
      path.push(num) // 选择当前的数，加入path
      used[num] = true // 记录一下 使用了
      dfs(path) // 基于选了当前的数，递归
      path.pop() // 上一句的递归结束，回溯，将最后选的数pop出来
      used[num] = false // 撤销这个记录
    }
  }

  dfs([]) // 递归的入口，空path传进去
  return res
}
```



### 方法二：双交换

```js
var permute = function(nums) {
  return nums.reduce(
    (result, num) => {
      return result.reduce((permutations, permutation) => {
        permutation.push(num)
        for (let i = permutation.length - 1; i; i--) {
          permutations.push([...permutation])
          permutation[i] = permutation[i - 1]
          permutation[i - 1] = num
        }
        permutations.push(permutation)
        return permutations
      }, [])
    },
    [[]]
  )
}
```

### 方法三：DP

```js
var permute = function(nums, n = 0) {
  if (n >= nums.length) return [[]]
  const res = []
  const prevs = permute(nums, n + 1) // permutations of elements after n
  for (let prev of prevs) {
    for (let i = 0; i <= prev.length; i++) {
      let p = prev.slice(0)
      p.splice(i, 0, nums[n]) // successively insert element n
      res.push(p)
    }
  }
  return res
}
```

### 方法四：

```js
var permute = function(nums) {
  let permutations = []

  let findPermutations = function(visited = new Set(), currPerm = []) {
    if (currPerm.length === nums.length) {
      permutations.push(currPerm)
      return
    }
    for (let i = 0; i < nums.length; i++) {
      if (!visited.has(i)) {
        findPermutations(new Set([...visited, i]), [...currPerm, nums[i]])
      }
    }
  }

  findPermutations()

  return permutations
}
```

## [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

### 方法一：迭代

1. 新建一个空链表
2. 连个指针迭代两个链表，根据大小拼接新的链表，并且指针要往后跟着移动
3. 如果l1或者l2，其中一个迭代完了，则拼接剩下的

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
const mergeTwoLists = function(l1, l2) {
  // 定义头结点，确保链表可以被访问到
  let head = new ListNode()
  // cur 这里就是咱们那根“针”
  let cur = head
  // “针”开始在 l1 和 l2 间穿梭了
  while (l1 && l2) {
    // 如果 l1 的结点值较小
    if (l1.val <= l2.val) {
      // 先串起 l1 的结点
      cur.next = l1
      // l1 指针向前一步
      l1 = l1.next
    } else {
      // l2 较小时，串起 l2 结点
      cur.next = l2
      // l2 向前一步
      l2 = l2.next
    }

    // “针”在串起一个结点后，也会往前一步
    cur = cur.next
  }

  // 处理链表不等长的情况
  cur.next = l1 !== null ? l1 : l2
  // 返回起始结点
  return head.next
}
```

### 方法二：递归

1. 子问题和原问题完全相同

```js
var mergeTwoLists = function(l1, l2) {
  if(l1 === null){
    return l2;
  }
  if(l2 === null){
    return l1;
  }
  if(l1.val < l2.val){
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  }else{
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
}
```

## [101_对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

### 方法一：递归

```js
var isSymmetric = function(root) {
  const check = (left, right) => {
    if(left === null && right === null) {
      return true
    }
	// 核心，检查是否满足条件
    if(left && right) {
      return left.val === right.val && check(left.left, right.right) && check(left.right, right.left)  
    }else {
      return false
    }

  }

  if(root == null) {
    return true
  } else {
    return check(root.left, root.right)
  }
}
```



### 方法二：迭代

```js
const check = (u, v) => {
  // 用栈来维护
  const q = []
  q.push(u),q.push(v)

  while (q.length) {
    u = q.shift()
    v = q.shift()

    if (!u && !v) continue
    if ((!u || !v) || (u.val !== v.val)) return false
	// 放入栈的顺序不要弄错
    q.push(u.left)
    q.push(v.right)

    q.push(u.right)
    q.push(v.left)
  }
  return true
}

var isSymmetric = function(root) {
  return check(root, root);
}
```

## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

### 方法一：递归DFS

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if(!root){
    return 0
  } else {
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
  }
};
```

### 方法二：迭代BFS

```js
var maxDepth = function(root) {
  var q = root ? [root] : [], l, d = 0
  console.log(q)
  while(q.length && ++d) {
    l = q.length
    while (l--) {
      var n = q.shift()
      n.right && q.push(n.right)
      n.left && q.push(n.left)
    }
  }
  return d
};

var maxDepth = function(root) {
  if(!root){
    return 0
  }

  let max = 0
  const stack = [[root, 0]]

  while (stack.length) {
    const [node, p] = stack.pop()

    max = Math.max(max, p + 1)

    node.left && stack.push([node.left, p + 1])
    node.right && stack.push([node.right, p + 1])
  }
  return max
};
```

## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

### 方法一：递归

```js
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
const invertTree = function(root) {
  // 定义递归边界
  if(!root) {
    return root;
  }
  // 递归交换右孩子的子结点
  let right = invertTree(root.right)
  // 递归交换左孩子的子结点
  let left = invertTree(root.left)
  // 交换当前遍历到的两个左右孩子结点
  root.left = right
  root.right = left
  return root
}
```

## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

题解在二叉树专题



## [1249. 移除无效的括号](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/)

使用栈抵消的思想，做括号问题：

- 遍历字符串，若遇到左括号，将其对应的索引入栈
- 若遇到右括号，有两种情况：
  - -栈中有值，说明之前有落单左括号，刚好匹配此右括号，作一次抵消，弹出栈顶
  - 栈中无值，说明之前没有落单的左括号了，当前右括号是多余的，删除
- 遍历完毕后，栈中剩下的值，是所有落单的左括号对应索引，将落单的左括号删除即可

```js
const minRemoveToMakeValid = s => {
    const stack = [];
    const res = s.split('');
    const len = res.length;
    for (let i = 0; i < len; i++) {
        if (res[i] === '(') stack.push(i);
        if (res[i] === ')') {
            if (stack.length > 0) {
                // 若栈中有值，说明之前有落单左括号
                // 刚好匹配右括号，作一次抵消
                stack.pop();
            } else {
                // 栈中无值，说明之前没有落单的左括号了
                // 当前右括号是多余的，删除
                res[i] = '';
            }
        }
    }
    // 栈中剩下的值，是所有落单的左括号
    const lenStack = stack.length;
    for (let i = 0; i < lenStack; i++) {
        // 将落单的左括号删除
        res[stack[i]] = '';
    }
    return res.join('');
};
```

## [301. 删除无效的括号](https://leetcode-cn.com/problems/remove-invalid-parentheses/)

### 方法一：DFS

枚举过程中出现字符分三种情况：

- 普通字符：无须删除，直接添加
- 左括号：如果当前得分不超过 max - 1 时，我们可以选择添加该左括号，也能选择不添加
- 右括号：如果当前得分大于 0（说明有一个左括号可以与之匹配），我们可以选择添加该右括号，也能选择不添加

```js
var removeInvalidParentheses = function(s) {
    const res = []
    let len = 0;
    let l = 0, r = 0
    for(const c of s){
        if(c == '(') l++
        else if(c == ')')r++
    }
    // 得到最少的括号数量
    const maxScore = Math.min(l,r)

    const dfs = (index, score, cur) =>{
        if(index == s.length){
            if(score === 0 && cur.length >= len){
                res.push(cur)
                len = Math.max(len, cur.length)
            }
            return
        }

        if(s[index] == '('){
            if(score + 1 <= maxScore) dfs(index + 1, score + 1, cur + '(')
            dfs(index + 1, score, cur)
        }else if(s[index] == ')'){
            if (score > 0) dfs(index + 1, score - 1, cur + ")");
            dfs(index + 1, score, cur);
        }else{
            dfs(index + 1, score, cur + s[index])
        }
    }

    dfs(0,0, '')
    return [...new Set(res)]
};
```

### 方法二：BFS

- 先对原字符串来一遍20.有效的括号，并改成只把"("和")"对应原字符串下标入栈。一顿括号匹配后，剩下的就是无效括号的“根源”。此时栈的长度就是删除最小数量，栈中元素就是多余的括号位置。
- 栈中元素满足以下规律：
  - ")"的位置绝对不会出现在"("的后面，即只有三种情况。
    - 全是")"。
    - 全是"("。
    - 左边x个")"右边y个"(" 如"))(("。
  - ")"对应的下标是所有可能无效的")"中最右边的，同样"("对应的下标是所有可能无效的"("中最左边的。
  - 若有栈中多个"(",")"的下标,"("中最小下标左边的括号字串必定是有效括号，"("中最大下标右边的括号字串必定也是有效括号，并且删除字串中任何的"("或")"都可以和栈中的"("或")"组成有效括号。例如"()())",最右边的无效括号下标是4,那么删除1,3,4的")"都可以形成有效括号字符串。当然删除3和4得到的字符串是一样的，加个set去重就OK了
- 把规律写入BFS中就完事了...（表面两次BSF，实际上是把"("和")"分别处理。")"逆序遍历，"("顺序遍历，还能减点枝）

```js
/**
 * @param {string} s
 * @return {string[]}
 */
var removeInvalidParentheses = function(s) {
    let index=[],str=[],arr=[s],se=new Set();
    for(let i=0;i<s.length;i++){
        if(s[i]==")"&&index.length&&s[index[index.length-1]]=="(") index.pop()
        else if(s[i]=="("||s[i]==")") index.push(i)
    }
    while(index.length){
        if(s[index[index.length-1]]==")") break;
        let a=[],b=index.pop();
        for(let j of arr){
            for(let i=b;i<j.length;i++){
                if(j[i]=="("){
                    let string_=j.slice(0,i)+j.slice(i+1)
                    if(!se.has(string_)){
                        se.add(string_);
                        a.push(string_)
                    }
                }
            }
        }
        arr=a; 
    }
    for(let k=0;k<index.length;k++){
        let a=[];
        for(let j of arr){
            for(let i=0;i<=index[k]-k;i++){
                if(j[i]==")"){
                    let string_=j.slice(0,i)+j.slice(i+1)
                    if(!se.has(string_)){
                        se.add(string_);
                        a.push(string_)
                    }
                }
            }
        }
        arr=a; 
    }
    return arr;
};
```

