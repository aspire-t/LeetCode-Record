# 排序

## [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

### 方法一：brute force  会超时

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var reversePairs = function(nums) {
    let cnt = 0;
    let len = nums.length;
    for (let i = 0; i < len - 1; i++) {
        for (let j = i + 1; j < len; j++) {
            if (nums[i] > nums[j]) {
                cnt++;
            }
        }
    }
    return cnt;
}
```

### 方法二：归并排序

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var reversePairs = function(nums) {
    // 归并排序
    let sum = 0;
    mergeSort(nums);
    return sum;

    function mergeSort (nums) {
        if(nums.length < 2) return nums;
        const mid = parseInt(nums.length / 2);
        let left = nums.slice(0,mid);
        let right = nums.slice(mid);
        return merge(mergeSort(left), mergeSort(right));
    }

    function merge(left, right) {
        let res = [];
        let leftLen = left.length;
        let rightLen = right.length;
        let len = leftLen + rightLen;
        for(let index = 0, i = 0, j = 0; index < len; index ++) {
            if(i >= leftLen) res[index] = right[j ++];
            else if (j >= rightLen) res[index] = left[i ++];
            else if (left[i] <= right[j]) res[index] = left[i ++];
            else {
                res[index] = right[j ++];
                sum += leftLen - i;//在归并排序中唯一加的一行代码
            }
        }
        return res;
    }
};



/**
 * @param {number[]} nums
 * @return {number}
 */
var reversePairs = function(nums) {
    let count = 0;
    mergeSort(nums);

    function mergeSort(arr){
        if(arr.length < 2) return arr;
        let mid = Math.floor(arr.length/2);
        let left = arr.slice(0, mid);
        let right = arr.slice(mid);
        return merge(mergeSort(left), mergeSort(right));
    }

    // 合并两个有序数组的过程中计数
    function merge(left, right){
        let leftLen = left.length, rightLen = right.length;
        let i = 0, j = 0;
        let temp = new Array(leftLen + rightLen);
        for(let cur = 0; cur < leftLen + rightLen; cur++){
            // 检查i, j有没有超界
            if(i >= leftLen) temp[cur]= right[j++];
            else if(j >= rightLen) temp[cur] = left[i++];
            else if(left[i] <= right[j]){
                temp[cur] = left[i++];
            }else{
                // left[i] > right[j]的情况, 即left[i, end)和right[j]都是逆序对
                temp[cur] = right[j++];
                count += leftLen - i;
            }
        }
        return temp;
    }
    return count;
};



var reversePairs = function (nums) {
  let res = 0;
  let temp = [];
  function reversePairs(arr, left, right) {
    if (left >= right) {
      return 0;
    }
    let mid = left + Math.floor((right - left) / 2);
    reversePairs(arr, left, mid);
    reversePairs(arr, mid + 1, right);
    merge(left, right, mid, arr);
    return res;
  }

  function merge(left, right, middle, arr) {
    //这里有一些拷贝的方法容易崩，直接赋值就好了。
    //为了节省点空间就把temp放在头上定义了
    for (let x = left; x <= right; x++) {
      //把需要的部分拷贝下来到temp中
      temp[x] = arr[x];
    }
    let i = left,
      j = middle + 1;
    for (let k = left; k <= right; k++) {
      if (i > middle) {
        arr[k] = temp[j++];
      } else if (j > right) {
        arr[k] = temp[i++];
      } else if (temp[i] <= temp[j]) {
        arr[k] = temp[i++];
      } else {
        arr[k] = temp[j++];
        res = res + middle - i + 1;
      }
    }
    return res;
  }
  
  reversePairs(nums, 0, nums.length - 1);
  return res;
};
```



