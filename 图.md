# 图

## [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

### 方法一：DFS

```js
class Graph {
    constructor(noOfVertices) {
        this.noOfVertices = noOfVertices; // 顶点数量
        this.adjList = new Map(); // 邻接表
    }

    // 增加顶点
    addVertex(v) {
        this.adjList.set(v, []);
    }

    // 增加单向边
    addEdge(v, w) {
        this.adjList.get(v).push(w);
    }

    dfs() {
        const visited = Array(this.noOfVertices).fill(false);
        const vertices = this.adjList.keys();

        for (let v of vertices) {
            if (!this.dfsUntil(v, visited)) return false;
        }
        return true;
    }
    dfsUntil(v, visited) {
        if (visited[v]) return false
        visited[v] = true
        
        const neighs = this.adjList.get(v);
        for (let neigh of neighs) {
            if (!this.dfsUntil(neigh, visited)) return false;
        }
        visited[v] = false;
        return true;
    }
}

/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function (numCourses, prerequisites) {
    var g = new Graph(numCourses);
    for (var i = 0; i < numCourses; i++) {
        g.addVertex(i);
    }
    prerequisites.forEach(([i, j]) => g.addEdge(i, j));
    return g.dfs();
};
```



### 方法二：BFS

```js
const canFinish = (numCourses, prerequisites) => {
  const inDegree = new Array(numCourses).fill(0); // 入度数组
  const map = {};                                 // 邻接表
  for (let i = 0; i < prerequisites.length; i++) {
    inDegree[prerequisites[i][0]]++;              // 求课的初始入度值
    if (map[prerequisites[i][1]]) {               // 当前课已经存在于邻接表
      map[prerequisites[i][1]].push(prerequisites[i][0]); // 添加依赖它的后续课
    } else {                                      // 当前课不存在于邻接表
      map[prerequisites[i][1]] = [prerequisites[i][0]];
    }
  }
  const queue = [];
  for (let i = 0; i < inDegree.length; i++) { // 所有入度为0的课入列
    if (inDegree[i] == 0) queue.push(i);
  }
  let count = 0;
  while (queue.length) {
    const selected = queue.shift();           // 当前选的课，出列
    count++;                                  // 选课数+1
    const toEnQueue = map[selected];          // 获取这门课对应的后续课
    if (toEnQueue && toEnQueue.length) {      // 确实有后续课
      for (let i = 0; i < toEnQueue.length; i++) {
        inDegree[toEnQueue[i]]--;             // 依赖它的后续课的入度-1
        if (inDegree[toEnQueue[i]] == 0) {    // 如果因此减为0，入列
          queue.push(toEnQueue[i]);
        }
      }
    }
  }
  return count == numCourses; // 选了的课等于总课数，true，否则false
};
```

