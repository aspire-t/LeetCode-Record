# 快慢指针遍历

## [141_环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

### 解法一：双指针，快慢指针

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  let first = head,
  last = head
  while(last!= null && last.next != null){
    first = first.next
    last = last.next.next
    // 如果有环，变成了追击问题，相遇的时候，也就是被套圈的时候
    if(first == last) {
      return true
    }
  }
  return false
};
```

### 解法二：JSON.stringify()

思路：JSON.stringify() 无法解决循环引用的问题，和深浅拷贝中遇到的问题一样。所以在这题中，反而变成了一种奇技淫巧。但是这个方法最大的问题就是比较慢。因为要爆栈了，才会报错

```js
var a = {}
a.a = a
console.log(JSON.stringify(a)) //Uncaught TypeError: Converting circular structure to JSON
```

```js
var hasCycle = function (head) {
  try {
    JSON.stringify(head)
  } catch (e) {
    return true
  }
  return false
}
```

### 解法三：HashMap

思路：通过hash表来检测节点之前是否被访问过

```js
var hasCycle = function (head) {
  if(!head || !head.next) return false
  let map = new Map()
  while(head){
    if(map.has(head)) return true
    map.set(head, true)
    head = head.next
  }
  return false
}
```



## [202_快乐数](https://leetcode-cn.com/problems/happy-number/)

这道题，就是按照题目的要求递归求解

### 解法一：快慢指针

```js
var isHappy = function (n) {
  let slow = sum(n)
  let fast = sum(slow)
  // 重点是这里，要跳出循环
  while (slow != fast) {
    slow = sum(slow)
    fast = sum(sum(fast))
  }
  return slow == 1
}

function sum(n) {
  n = n + ''
  let sum = 0
  for (let num of n) {
    sum += num * num
  }
  return sum
}
```

### 解法二：使用对象存储

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function (n) {
  let res = sum(n)
  let obj = {}
  // 重点是这里，要跳出循环
  while (res != 1) {
    if (res in obj) return false
    obj[res] = 1
    res = sum(res)
  }
  return true
}

function sum(n) {
  n = n + ''
  let sum = 0
  for (let num of n) {
    sum += num * num
  }
  return sum
}
```



## [876_链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

### 解法一：单指针

- 循环一遍，找到链表中总共有几个值
- 取一半的值，再次循环，找到对应的值

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var middleNode = function(head) {
  let node = head
  let n = 0
  while(node) {
    n++
    node = node.next
  }

  let count = Math.floor(((n) / 2))

  while(count > 0){
    count--
    head = head.next
  }
  return head
};
```

### 解法二：快慢指针

**快指针**每次**走两**步，**慢指针**每次**走一**步，当快指针走到走到**终点**时，慢指针刚好走到**中间**

```js
var middleNode = function (head) {
  let fast = head,
    slow = head
  while (fast && fast.next) {
    fast = fast.next.next
    slow = slow.next
  }
  return slow
}
```

### 解法三：数组

遍历，用**数组记录**链表，res[**len>>1**]为其**中间节点**（**位运算**比除法**效率高**一点，**优先**级也高）

这个的原理和快慢指针类似

```js
var middleNode = function (head) {
  let len = 0,
    newHead = head,
    res = []
  while (newHead) {
    res[len++] = newHead
    newHead = newHead.next
  }
  return res[len >> 1]
}
```



相关题目：142，287，19，234